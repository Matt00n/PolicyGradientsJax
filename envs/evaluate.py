from copy import copy
from typing import List, Tuple

import gymnasium as gym

from envs.base import VecEnv, VecEnvWrapper
from envs.state import State



class RecordScores(gym.Wrapper):
    """
    Records episode scores.
    """
    def __init__(self, env: gym.Env):
        gym.Wrapper.__init__(self, env)
        self.episode_return = 0
        self.episode_length = 0

    def step(self, action):
        obs, reward, term, trunc, info = self.env.step(action)
        self.episode_return += reward
        self.episode_length += 1
        if term or trunc:
            info['episode_return'] = self.episode_return
            info['episode_length'] = self.episode_length
        return obs, reward, term, trunc, info
    
    def reset(self, seed=None):
        self.episode_return = 0
        self.episode_length = 0
        return self.env.reset(seed=seed)


class Evaluator(VecEnvWrapper):
    """
    Accumulates episode metrics generated by RecordScores and tracks 
    the number of completed episodes.

    :param venv: the vectorized environment to wrap.
    """

    def __init__(
        self,
        venv: VecEnv,
    ):
        VecEnvWrapper.__init__(self, venv)

        self.returns = []
        self.episode_lengths = []


    def step_wait(self) -> Tuple[State, List]:
        """
        Apply sequence of actions to sequence of environments
        actions -> (observations, rewards, dones)

        where ``dones`` is a boolean vector indicating whether each element is new.
        """
        env_state = self.venv.step_wait()
        for info in env_state.info:
            if 'episode_return' in info:
                self.returns.append(info['episode_return'])
                self.episode_lengths.append(info['episode_length'])
        return env_state

    def evaluate(self) -> Tuple[List, List]:
        """Report recorded metrics and reset them internally."""
        returns = copy(self.returns)
        episode_lengths = copy(self.episode_lengths)
        self.returns = []
        self.episode_lengths = []
        return returns, episode_lengths

    def reset(self) -> State:
        """
        Reset all environments
        :return: first observation of the episode
        """
        return self.venv.reset()
